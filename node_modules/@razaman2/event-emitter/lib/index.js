"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class EventEmitter {
    constructor() {
        this.events = [];
        this.errors = '@error';
        this.types = {
            once: 'once',
            standard: 'standard'
        };
    }
    on(subscriptions, handlers) {
        return this.register(subscriptions, handlers);
    }
    once(name, handlers) {
        return this.register(name, handlers, this.types.once);
    }
    off(name) {
        this.remove(name);
    }
    emit(name, ...params) {
        if (name) {
            const event = this.find(name);
            if (event) {
                event.handlers.forEach((handler) => this.invoke(handler, params));
            }
            if (event && (event.type === this.types.once)) {
                this.remove(event.name);
            }
        }
        else {
            const promises = this.events.map((event) => {
                return new Promise((resolve) => {
                    event.handlers.forEach((handler) => this.invoke(handler, params));
                    if (event.type === this.types.once) {
                        this.remove(event.name);
                    }
                    resolve();
                });
            });
            Promise.all(promises);
        }
    }
    find(name) {
        return this.events.find((event) => event.name === name);
    }
    remove(name) {
        this.events = this.events.filter((event) => event.name !== name);
    }
    invoke(handler, params) {
        try {
            handler(...params);
        }
        catch (e) {
            this.emit(this.errors, e);
        }
    }
    register(subscriptions, handlers, type) {
        if (typeof subscriptions === "string") {
            if (typeof handlers === "function") {
                handlers = [handlers];
            }
            this.events.push({
                name: subscriptions,
                type: type !== null && type !== void 0 ? type : this.types.standard,
                handlers: handlers
            });
            return { [subscriptions]: () => this.remove(subscriptions) };
        }
        else {
            return Object.entries(subscriptions).reduce((subscriptions, [key, value]) => {
                if (key.length && !this.find(key)) {
                    this.events.push({
                        name: key,
                        type: type !== null && type !== void 0 ? type : this.types.standard,
                        handlers: Array.isArray(value) ? value : [value]
                    });
                    subscriptions[key] = () => this.remove(key);
                }
                else if (key.length) {
                    subscriptions[key] = () => this.remove(key);
                }
                return subscriptions;
            }, {});
        }
    }
}
exports.default = EventEmitter;
//# sourceMappingURL=index.js.map