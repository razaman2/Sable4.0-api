export default class EventEmitter {
    protected events: Array<{
        name: string;
        type: string;
        handlers: Array<Function>;
    }> = [];

    private errors = '@error';

    private types = {
        once: 'once',
        standard: 'standard'
    };

    public on(subscriptions: string | object, handlers?: Array<Function> | Function) {
        return this.register(subscriptions, handlers);
    }

    public once(name: string | object, handlers?: Array<Function> | Function) {
        return this.register(name, handlers, this.types.once);
    }

    public off(name: string) {
        this.remove(name);
    }

    public emit(name?: string, ...params: any) {
        if (name) {
            const event = this.find(name);

            if (event) {
                event.handlers.forEach((handler) => this.invoke(handler, params));
            }

            if (event && (event.type === this.types.once)) {
                this.remove(event.name);
            }
        } else {
            const promises = this.events.map((event) => {
                return new Promise<void>((resolve) => {
                    event.handlers.forEach((handler) => this.invoke(handler, params));

                    if (event.type === this.types.once) {
                        this.remove(event.name);
                    }

                    resolve();
                });
            });

            Promise.all(promises);
        }
    }

    private find(name: string) {
        return this.events.find((event) => event.name === name);
    }

    private remove(name: string) {
        this.events = this.events.filter((event) => event.name !== name);
    }

    private invoke(handler: Function, params: Array<any>) {
        try {
            handler(...params);
        } catch (e) {
            this.emit(this.errors, e);
        }
    }

    private register(subscriptions: string | object, handlers?: Array<Function> | Function, type?: string) {
        if (typeof subscriptions === "string") {
            if (typeof handlers === "function") {
                handlers = [handlers];
            }

            this.events.push({
                name: subscriptions,
                type: type ?? this.types.standard,
                handlers: handlers as Array<Function>
            });

            return {[subscriptions]: () => this.remove(subscriptions)};
        } else {
            return Object.entries(subscriptions).reduce((subscriptions: { [p: string]: Function }, [key, value]) => {
                if (key.length && !this.find(key)) {
                    this.events.push({
                        name: key,
                        type: type ?? this.types.standard,
                        handlers: Array.isArray(value) ? value : [value]
                    });

                    subscriptions[key] = () => this.remove(key);
                } else if (key.length) {
                    subscriptions[key] = () => this.remove(key);
                }

                return subscriptions;
            }, {});
        }
    }
}
